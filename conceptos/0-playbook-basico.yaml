- # PLAY: 'Programa': Un estado en el quiero encontrar un entorno remoto
    # vamos a tener un fichero de inventario. 
    # Esta marca limita dentro de ese inventario donde puedo ejecutar el playbook.
    # Este no es el único sitio donde establecer esta limitación.
    # Es mucho más frecuente, esa limitación hacerla en tiempo de ejecución.
    # Así es más flexible.
    hosts: localhost        # Entornos en los que poder ejecutar este play
                            # Una práctica habitual es poner:
                            # - "all": Todos los del inventario
                            # - nombre de host: "localhost", "mipc17", "bbdd.produccion.es"
                            # - rango de maquinas: "bbdd1.produccion.es:bbdd9.produccion.es"
                            # - grupo: Los hosts, en los inventarios, los podré clasificar en grupos.
                            #   "produccion"
                            #   "servidores-web"
                            # - Combinaciones de grupos
                            #   "servidores-web:&produccion" Los servidores web de producción
                            #   "servidores-web:!produccion" Los servidores web de no son de producción
    
    # Al ejecutarse sobre 25 servidores... Como funciona eso? 
    # Se va de 1 en 1 o cómo? Depende cómo configure la ejecución.
    # Definiremos un tamaño de pool de ejecutores: Cuantos en paralelo: 7
    # Y en que orden se van procesando? Da igual?
    # Me temo que on... Hay muchos escenarios donde NO DA IGUAL:
    # SQL Server Activo / Replica:
    # 1º Activo.   actualiza a la nueva versión
    #                VVV
    # 2º Replica.  actualiza a la nueva versión
    
    # Activo/Pasivo: H/A
    # IIS Maquina 1 - Running
    # IIS Maquina 2 - Pasivo - StandBy

    # Actualizo el standby tranquilidad... Si se jode no pasa nada... no corto servicio
    # Cambio... y ya actualizo el que era activo
    order: inventory            # Según el orden del inventario
         # sorted               # Orden alfabético 
         # reversed_sorted      # Orden alfabético descendente
         # reversed_inventory   # Orden del inventario invertido 
         # shuffle              # Orden aleatorio

    gather_facts: True 
                 #False     # Desactivo completamente que se lean datos del entorno remoto
                            # Por defecto, Ansible se trae un huevon de datos del remoto.
                            # En la práctica no quiero NI LO UNO NI LO OTRO.

    vars:                   # Definir variables para su uso dentro del playbook
                            # Parametros, configuraciones personalizables que puedo hacer sobre los plays
        mi_variable1: VALOR1
        mi_variable2: VALOR2
        instalar:   false

    pre_tasks:
        -   name: Pretarea 1
            debug: # Este módulo lo único que hace es sacar un triste mensaje por pantalla.
                msg: Soy la PREtarea 1... y me estoy ejecutando.

    tasks:                  # QUITAR LA PALABRA TASK DE VUESTRO CEREBRO. Aqui la tengo que poner
                            # Definir los ESTADOS ddeseados.
#        -   name:
#            tipo:  # Corresponde con un MODULO DE ANSIBLE
#                parametrizacion...
        -   name: Tarea 1
            debug: # Este módulo lo único que hace es sacar un triste mensaje por pantalla.
                msg: Soy la tarea 1... y me estoy ejecutando.
                
#            ejecutar-script-powershell...
#            Que sabe el modulo de si aquello ha realizado cambios?

        -   name: Tarea 2 - Mostrar las ips recopiladas de la máquina
            debug: # Este módulo lo único que hace es sacar un triste mensaje por pantalla.
                var: ansible_facts.all_ipv4_addresses
            
        -   name: Tarea 3 - Mostrar variable 1
            debug: # Este módulo lo único que hace es sacar un triste mensaje por pantalla.
                var: mi_variable1
            
        -   name: Tarea 4 - Mostrar variable 2
            debug: # Este módulo lo único que hace es sacar un triste mensaje por pantalla.
                var: mi_variable2

        -   name: Tarea 5 - Mostrar variable 2... con una redefinición
            debug: # Este módulo lo único que hace es sacar un triste mensaje por pantalla.
                var: mi_variable2.clave2[0]
            vars:
                mi_variable2: 
                    clave1: 33
                    clave2:
                        - item1
                        - True

        -   name: Tarea 6 - Mostrar variable 2
            debug: # Este módulo lo único que hace es sacar un triste mensaje por pantalla.
                var: mi_variable2

        # Logica al playbook
        
        # Condicionales
        -   name: Tarea 7 - Mostrar un mensaje solo si hay que instalar
            debug: # Este módulo lo único que hace es sacar un triste mensaje por pantalla.
                msg: Vamos a instalar !!!!!!
            when:    instalar
            #when:   instalar == true
            
        -   name: Tarea 8 - Cambiar el fichero de configuracíon A
            debug: # Este módulo lo único que hace es sacar un triste mensaje por pantalla.
                msg: Cambiando el fichero A.....
            # Expresión lógica (IF) para determinar si esta tarea debe considerarse que ha provocado un cambio
            changed_when: true #
            # La tarea que notificamos SOLO ES ACTIVADA si esta tarea.. 
            # la que estoy definiendo en estas lineas.... TAREA 8
            # Provoca un CAMBIO : CHANGED
            notify: Tarea B - REINICIO DEL SISTEMA
                
        -   name: Tarea 9 - Cambiar el fichero de configuracíon B
            debug: # Este módulo lo único que hace es sacar un triste mensaje por pantalla.
                msg: Cambiando el fichero B.....
            changed_when: true #
            # En este caso, si esta tarea provoca un cambio (changed),
            # Se notifica un EVENTO, lo que implica que TODAS LAS TAREAS
            # Que escuchan el evento, se ejecutan.
            notify: CAMBIO-CONFIGURACION 

        -   meta: flush_handlers        # Fuerza la ejecución de los handlers que hayan sido activados
                                        # en este momento de la ejecución

        -   name: Tarea 10 - Otras cosas que hay que hacer....
            debug: # Este módulo lo único que hace es sacar un triste mensaje por pantalla.
                msg: Muchas cosas
            # Expresión lógica (IF) para determinar si esta tarea debe considerarse que ha provocado un fallo
            failed_when: false #

    post_tasks:
        -   name: Posttarea 1
            debug: # Este módulo lo único que hace es sacar un triste mensaje por pantalla.
                msg: Soy la Posttarea 1... y me estoy ejecutando.
        
        # Bucles
        -   name: Tarea que se ejecuta en bucle
            debug:
                msg: |-
                    Soy la tarea que abre puertos del firewall de windows.
                    Voy a abrir el puerto: {{ item }}
            loop: "{{ puertos }}"
            vars:
                puertos: #[80, 8080, 8443]
                    - 80
                    - 8080
                    - 8443
                    
        -   name: Ejecutar script
            #win_shell: |
            shell: |
                echo HOLA
                ls -l
            register: SALIDA_SCRIPT

        -   name: Ver salida script
            debug:
                msg: |
                    Codigo salida: {{ SALIDA_SCRIPT.rc }}
                    Comando: {{ SALIDA_SCRIPT.cmd }}
                    stdout: {{ SALIDA_SCRIPT.stdout }}

        # Bucles
        -   name: Tarea que se ejecuta en bucle
            shell: |
                  echo PUERTO: {{ item }}
            loop: "{{ puertos }}"
            vars:
                puertos: #[80, 8080, 8443]
                    - 80
                    - 8080
                    - 8443
            register: SALIDA_PROGRAMA_PUERTOS

        -   name: Ver salida script
            debug:
                var: SALIDA_PROGRAMA_PUERTOS.results[1].stdout

        # Control de errores
        
        -   name: Hago copia de seguridad
            debug:
                msg: Hago copia de seguridad
                
        -   name: Nombre del bloque
            block:
                -   name: Tarea delicada, que puede fallar
                    shell: exit 1
            rescue: # Pondremos tareas que queremos ejecutar si alguna de las tareas del bloque ha fallado
                -   name: Restauro copia de seguridad
                    debug:
                        msg: Restauro copia de seguridad
            always: # Pondremos tareas que queremos ejecutar siempre, con independencia de si alguna tarea falló
                -   name: Borrar copia de seguridad
                    debug:
                        msg: Borrar copia de seguridad
            #vars:
            #when: CONDICION
        


# Otras tareas, que se podrán ejecutar o no, dependiendo si han sido activadas.
# En caso de que un handler sea activado(notify), 
# su ejecución es postpuesta hasta el final de las tareas del bloque (pretasks, tasks, posttasks)
# desde el que se hizo el notify.

    handlers:
        
        -   name: Tarea A - PARADA DEL SISTEMA
            debug: # Este módulo lo único que hace es sacar un triste mensaje por pantalla.
                msg: Parada del sistema
            listen: CAMBIO-CONFIGURACION # Le asociamos un evento 
                
        -   name: Tarea B - REINICIO DEL SISTEMA
            debug: # Este módulo lo único que hace es sacar un triste mensaje por pantalla.
                msg: Reinicio el sistema
            listen: CAMBIO-CONFIGURACION 

        